package com.ready;
/*
 * 方法的重写：
 * 返回值类型，方法名，参数类型及个数都与父类继承的方法相同；
 * 重新方法会优先调用子类的方法
 * 
 * 继承的初始化顺序：
 * 1、先初始化父类再初始化子类
 * 2、限制性初始化对象中属性，再执行构造方法中的初始化
 * 
 * 属性的初始化先执行，然后再执行构造方法
 * 所以：父类初始化属性，然后父类初始化构造方法，然后子类初始化属性，子类初始化构造方法。
 * 
 * final关键字修饰类，方法，属性和变量
 * final修饰类，类不可以被集成
 * final修饰方法，方法不允许被覆盖
 * final修饰属性，属性不会被隐式的初始化，必须要类的初始化赋值或者是在构造方法中赋值，二者选其一。（属性：在类中的变量），如果没有final关键字，会自动进行默认赋值。
 * final修饰变量，变量智能赋值一次，只能在声明的时候初始化一次。
 * 
 * super关键字，用在类的内部，调用父类
 * super.属性 调用父类的属性
 * super。方法  调用父类的方法
 * 
 * 子类的构造过程当中必须要调用父类的构造方法
 * 如果子类的构造方法没有调用构造方法，那么程序会隐式的调用父类的构造方法
 * 如果子类中显示的调用构造方法，super()必须放到第一行
 * 
 * 如果子类构造方法中既没有显示调用父类的构造方法，而父类又没有无惨的构造方法，编译就会出错，因为隐式调用就是执行super(),不传递参数。
 * 如果说没有定义构造方法，系统会隐式的创建无参的构造方法，如果说定义了构造方法，那么系统就不会再创建构造方法。
 * 
 * Object是所有类的父类，没有用extends显示的表达集成另外一个类，就是默认集成了object类。
 * Object类中的方法适合所有的子类。
 * Object里面的关键的方法：
 * toString()方法：返回的对象是哈希码（对象地址字符串）。用来区分每个对象。
 * 重写toString()方法来输出对象的属性。
 * 
 * equals()方法：比较的是对象的引用是否只想同一块内存地址。
 * 默认的equals()是比较两个对象是不是一个对象
 * 通常需要的比较equals()是问两个对象是不是同一类的对象（也就是对象的属性是不是相同）
 * == 比较的也是对象的内存地址
 * 所以比较属性是否相同，也要重写equals()方法。
 * 
 * 
 * 继承是多态的基础
 * 
 * 引用的多态：
 * 父类的引用可以指向本类的对象；
 * 父类的引用可以指向子类的对象；
 * 
 * 方法的多态：
 * 创建本类对象：调用的方法为本类的方法；
 * 创建的子类对象时，调用的方法是子类重写的方法，或者是继承的方法
 * 
 * 
 * 多态中的引用类型转换：
 * 1、向上类型转换（隐式/自动类型转换），是小类型到大类型的转换（没有风险）
 * 2、向下类型转换（强制类型转换），大类型到小类型（因为可能会发生数据的溢出）（有风险）
 * 3、通过instanceof运算符来解决引用对象的类型，避免类型转换的安全问题。
 * 
 * 
 * 抽象类：
 * 在某些情况下，某个父类只知道子类应该包含什么样的方法，但是无法准确知道子类如何实现这些方法。
 * 抽象类只关注子类需要有什么方法，并不关心它的实现。
 * 
 * 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性
 * 
 * 作用： 限制子类有什么方法，但是不关注实现。
 * 
 * 使用规则：
 * 1、abstract定义抽象类
 * 2、abstract定义抽象方法，只有声明，不需要实现
 * 3、包含抽象方法的类是抽象类
 * 4、抽象类中可以包含普通的方法，也可以没有抽象方法
 * 5、抽象类不能直接创建，可以定义引用变量，指向子类的对象（通常的使用情形）
 * 
 * 接口：
 * 接口可以理解为一种特殊的类，由全局常量和公共的抽象方法组成
 * 如果说类是具体的实现体，接口定义了某一批类所需要遵守的规范，接口不关心类的内部数据，也不关心这些类里方法的实现的细节，它只规定这些类里必须提供某种方法
 * 接口是规范，是来约束类的
 * 
 * interface关键字
 * interface一般用来继承或者被实现的，所以一般是public，而且接口一般是abstract，如果没有会被加上
 * 接口可以多继承
 * 接口中的属性是常量
 * public static final修饰符号，不自己加系统就会自己加上
 * 接口中的方法都是抽象方法 public abstract。
 * 
 * 实现接口使用implements，一个类可以实现一个或者多个接口
 * 修饰符 class 类名 extends 父类  implements 接口1，接口2.。。
 * 如果继承了抽象类，必须要实现继承的抽象类里面的抽象方法，要实现接口中的抽象方法
 * 如果要继承父类，继承父类必须在实现接口之前。，也就是说extends和implements关键字的顺序不能调换
 * 
 * 
 * 
 */
public class Dog extends Animal{
	public void eat() {
		System.out.println("狗吃东西的能力");
	}
	public void watchDoor() {
		System.out.println("看门");
	}
	public Dog() {//构造方法
		//super()其实是隐式显示了，super()写于不写都是一样的
		System.out.println("Dog类执行了");
	}
	@Override
	public String toString() {//filed就是属性，eclipse可以通过source generate toString的方法来重写方法。
		return "Dog [age=" + age + "]";
	}
	public static void main(String[] args) {
		Dog dog = new Dog();
		dog.age = 10;
		System.out.println(dog.age);
	}
	
}
